
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { db } from "@/lib/db";
import { apps } from "@/lib/db/schema";
import { parseAppFile } from "@/lib/parser";
import { unlink, writeFile } from "fs/promises";
import { join } from "path";
import { tmpdir } from "os";
import { randomUUID } from "crypto";
import { revalidatePath } from "next/cache";
import fs from "fs";
import { cookies } from "next/headers";

// Increase body limit for this route segment (runtime config)
export const config = {
    api: {
        bodyParser: false, // Disallow default parsing, we might handle stream manually or let formData handle it if capable
    },
};
// Note: In App Router, 'config' export works differently or is not supported the same way as Pages router.
// We rely on global config or standard request handling.

export async function POST(request: NextRequest) {
    const tempPath = join(tmpdir(), `${randomUUID()}-upload`);

    try {
        const formData = await request.formData();
        const file = formData.get("file") as File;

        if (!file) {
            return NextResponse.json({ error: "No file uploaded" }, { status: 400 });
        }

        // Security Check
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();
        const cookieStore = await cookies();
        const devRole = cookieStore.get('dev_role')?.value;

        if (!user && devRole !== 'admin') {
            return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        // Convert Buffer
        const buffer = Buffer.from(await file.arrayBuffer());
        await writeFile(tempPath, buffer);

        console.log("File saved to temp:", tempPath);

        // Parse Metadata
        const metadata = await parseAppFile(tempPath);
        console.log("Parsed Metadata:", metadata);

        // Upload to Supabase Storage
        const fileExt = file.name.split('.').pop();
        const storagePath = `${metadata.os}/${metadata.bundleId}/${metadata.version}-${metadata.buildNumber}.${fileExt}`;
        const fileStream = fs.createReadStream(tempPath);

        const { data: uploadData, error: uploadError } = await supabase.storage
            .from('apps')
            .upload(storagePath, fileStream as any, {
                contentType: file.type,
                duplex: 'half',
                upsert: true
            });

        if (uploadError) {
            console.warn("Storage upload failed (possibly demo mode):", uploadError.message);
        }

        const publicUrl = uploadData?.path
            ? supabase.storage.from('apps').getPublicUrl(storagePath).data.publicUrl
            : "#";

        // Insert to DB
        await db.insert(apps).values({
            name: metadata.name,
            bundleId: metadata.bundleId,
            os: metadata.os,
            version: metadata.version,
            buildNumber: metadata.buildNumber,
            fileUrl: publicUrl,
            description: "Uploaded via Dashboard",
        });

        return NextResponse.json({ success: true });

    } catch (error: any) {
        console.error("Upload API Error:", error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    } finally {
        try {
            if (fs.existsSync(tempPath)) {
                await unlink(tempPath);
            }
        } catch (e) {
            console.error("Cleanup error:", e);
        }
    }
}
